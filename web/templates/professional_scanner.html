<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <script>
        (function() {
            const t=(localStorage.getItem("rc-theme")||"dark");
            document.documentElement.setAttribute("data-theme",t);
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Professional Scanner - RentalCore</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.2/font/bootstrap-icons.css" rel="stylesheet">
    <link href="/static/css/rental-core-design.css" rel="stylesheet">
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#0d6efd">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <style>
        :root {
            --scanner-primary: #0d6efd;
            --scanner-success: #198754;
            --scanner-warning: #ffc107;
            --scanner-danger: #dc3545;
        }

        body {
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background: #000;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .professional-scanner {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
            overflow: hidden;
        }

        .camera-viewport {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        #camera-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform-origin: center;
        }

        .scanner-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background:
                linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 30%, transparent 70%, rgba(0,0,0,0.8) 100%),
                linear-gradient(to right, rgba(0,0,0,0.8) 0%, transparent 30%, transparent 70%, rgba(0,0,0,0.8) 100%);
        }

        .scanner-reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 280px;
            height: 180px;
            border: 3px solid rgba(13, 110, 253, 0.8);
            border-radius: 12px;
            pointer-events: none;
            transition: all 0.3s ease;
            background: rgba(13, 110, 253, 0.1);
        }

        .scanner-reticle.scanning {
            border-color: #20c997;
            background: rgba(32, 201, 151, 0.15);
            box-shadow:
                0 0 30px rgba(32, 201, 151, 0.5),
                inset 0 0 20px rgba(32, 201, 151, 0.1);
            animation: scannerPulse 2s infinite;
        }

        .scanner-reticle.found {
            border-color: var(--scanner-success);
            background: rgba(25, 135, 84, 0.2);
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow:
                0 0 40px rgba(25, 135, 84, 0.8),
                inset 0 0 30px rgba(25, 135, 84, 0.2);
        }

        @keyframes scannerPulse {
            0%, 100% {
                border-color: #20c997;
                box-shadow: 0 0 30px rgba(32, 201, 151, 0.5);
            }
            50% {
                border-color: #17a2b8;
                box-shadow: 0 0 50px rgba(23, 162, 184, 0.7);
            }
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #20c997, transparent);
            opacity: 0;
            animation: scanLineAnimation 2.5s ease-in-out infinite;
        }

        @keyframes scanLineAnimation {
            0% { top: 0; opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { top: 100%; opacity: 0; }
        }

        .scanner-reticle.scanning .scan-line {
            opacity: 1;
        }

        .corner-guide {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 4px solid #fff;
        }

        .corner-guide.top-left {
            top: -2px;
            left: -2px;
            border-right: none;
            border-bottom: none;
            border-radius: 12px 0 0 0;
        }

        .corner-guide.top-right {
            top: -2px;
            right: -2px;
            border-left: none;
            border-bottom: none;
            border-radius: 0 12px 0 0;
        }

        .corner-guide.bottom-left {
            bottom: -2px;
            left: -2px;
            border-right: none;
            border-top: none;
            border-radius: 0 0 0 12px;
        }

        .corner-guide.bottom-right {
            bottom: -2px;
            right: -2px;
            border-left: none;
            border-top: none;
            border-radius: 0 0 12px 0;
        }

        .status-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 1000;
            text-align: center;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .control-panel {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 1000;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            cursor: pointer;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }

        .control-btn.active {
            background: var(--scanner-warning);
            color: #000;
            border-color: var(--scanner-warning);
        }

        .control-btn.primary {
            width: 80px;
            height: 80px;
            background: var(--scanner-primary);
            border-color: var(--scanner-primary);
            font-size: 2rem;
        }

        .control-btn.primary.scanning {
            background: var(--scanner-success);
            animation: pulseControl 2s infinite;
        }

        @keyframes pulseControl {
            0% {
                box-shadow: 0 0 0 0 rgba(25, 135, 84, 0.7);
            }
            70% {
                box-shadow: 0 0 0 15px rgba(25, 135, 84, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(25, 135, 84, 0);
            }
        }

        .focus-indicator {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid var(--scanner-warning);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .focus-indicator.active {
            opacity: 1;
            animation: focusAnimation 1s ease-out;
        }

        @keyframes focusAnimation {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        .result-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.4);
            z-index: 2000;
            display: none;
            max-width: 90vw;
            text-align: center;
            backdrop-filter: blur(20px);
        }

        .result-modal.show {
            display: block;
            animation: modalSlideUp 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes modalSlideUp {
            from {
                opacity: 0;
                transform: translate(-50%, 50%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1900;
            display: none;
            backdrop-filter: blur(8px);
        }

        .modal-backdrop.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .result-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: white;
        }

        .result-icon.success {
            background: var(--scanner-success);
        }

        .result-icon.pack {
            background: var(--scanner-warning);
            color: #000;
        }

        .result-icon.error {
            background: var(--scanner-danger);
        }

        .quality-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-family: monospace;
            z-index: 1000;
        }

        .torch-control {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="professional-scanner">
        <!-- Camera Viewport -->
        <div class="camera-viewport">
            <video id="camera-video" autoplay muted playsinline></video>
            <canvas id="scan-canvas" style="display: none;"></canvas>

            <!-- Scanner Overlay -->
            <div class="scanner-overlay">
                <div class="scanner-reticle scanning" id="scanner-reticle">
                    <div class="corner-guide top-left"></div>
                    <div class="corner-guide top-right"></div>
                    <div class="corner-guide bottom-left"></div>
                    <div class="corner-guide bottom-right"></div>
                    <div class="scan-line"></div>
                </div>
            </div>

            <!-- Focus Indicator -->
            <div class="focus-indicator" id="focus-indicator"></div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar" id="status-bar">
            <i class="bi bi-camera-video"></i> Initializing professional camera...
        </div>

        <!-- Quality Indicator -->
        <div class="quality-indicator" id="quality-indicator">
            Camera: Starting...<br>
            Focus: Auto<br>
            Detection: Ready
        </div>

        <!-- Torch Control -->
        <div class="torch-control">
            <button class="control-btn" id="torch-btn" onclick="toggleTorch()" style="display: none;">
                <i class="bi bi-lightbulb"></i>
            </button>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <button class="control-btn" onclick="switchCamera()" title="Switch Camera" id="switch-btn" style="display: none;">
                <i class="bi bi-camera-reels"></i>
            </button>

            <button class="control-btn primary scanning" id="scan-btn" onclick="toggleScanning()" title="Scan">
                <i class="bi bi-camera" id="scan-icon"></i>
            </button>

            <button class="control-btn" onclick="closeScanner()" title="Close">
                <i class="bi bi-x-lg"></i>
            </button>
        </div>
    </div>

    <!-- Modal Backdrop -->
    <div class="modal-backdrop" id="modal-backdrop" onclick="closeModal()"></div>

    <!-- Result Modal -->
    <div class="result-modal" id="result-modal">
        <div class="result-icon success" id="result-icon">
            <i class="bi bi-check-lg"></i>
        </div>
        <h4 id="result-title">Device Scanned!</h4>
        <div class="mt-3">
            <p><strong>Device:</strong> <span id="result-device"></span></p>
            <p><strong>Status:</strong> <span id="result-status"></span></p>
            <p><strong>Action:</strong> <span id="result-action"></span></p>
        </div>

        <div class="mt-4">
            <button class="btn btn-success me-2" id="process-btn" onclick="processResult()">
                <i class="bi bi-check-circle"></i> <span id="process-text">Process</span>
            </button>
            <button class="btn btn-primary" onclick="continueScan()">
                <i class="bi bi-camera"></i> Continue
            </button>
        </div>
    </div>

    <!-- ZXing for barcode detection - using proven working version -->
    <script src="https://unpkg.com/@zxing/library@0.20.0/umd/index.min.js"></script>

    <script>
        class ProfessionalBarcodeScanner {
            constructor() {
                this.isInitialized = false;
                this.isScanning = false;
                this.torchEnabled = false;
                this.codeReader = null;
                this.currentStream = null;
                this.lastScanTime = 0;
                this.scanCooldown = 800;
                this.currentDeviceIndex = 0;
                this.videoDevices = [];
                this.jobID = {{.jobID}};
                this.lastDetectedCode = null;

                // Enhanced camera capabilities
                this.capabilities = {
                    torch: false,
                    zoom: false,
                    focus: false
                };

                this.init();
            }

            async init() {
                try {
                    this.updateStatus('Initializing professional camera system...', 'info');

                    // Initialize ZXing with simple, working configuration
                    try {
                        this.codeReader = new ZXing.BrowserBarcodeReader();
                        console.log('ZXing BrowserBarcodeReader initialized successfully');
                    } catch (error) {
                        console.error('ZXing initialization failed:', error);
                        throw new Error('Barcode scanner not supported on this device');
                    }

                    // Get available video devices
                    this.videoDevices = await this.codeReader.listVideoInputDevices();

                    if (this.videoDevices.length === 0) {
                        throw new Error('No camera found on this device');
                    }

                    // Show camera switch button if multiple cameras
                    if (this.videoDevices.length > 1) {
                        document.getElementById('switch-btn').style.display = 'flex';
                    }

                    // Setup professional camera
                    await this.setupProfessionalCamera();

                    // Setup interaction handlers
                    this.setupInteractionHandlers();

                    // Start continuous scanning
                    this.startContinuousScanning();

                    this.isInitialized = true;
                    this.updateStatus('Professional scanner ready - Position barcode in frame', 'success');

                } catch (error) {
                    console.error('Professional scanner initialization failed:', error);
                    this.updateStatus('Camera access failed: ' + error.message, 'error');
                }
            }

            async setupProfessionalCamera() {
                // Prefer back camera for mobile devices
                const preferredDevice = this.videoDevices.find(device =>
                    device.label.toLowerCase().includes('back') ||
                    device.label.toLowerCase().includes('rear') ||
                    device.label.toLowerCase().includes('environment')
                ) || this.videoDevices[0];

                this.currentDeviceIndex = this.videoDevices.indexOf(preferredDevice);

                // Professional camera constraints for optimal barcode scanning
                const constraints = {
                    video: {
                        deviceId: { exact: preferredDevice.deviceId },
                        width: { ideal: 1920, min: 1280 },
                        height: { ideal: 1080, min: 720 },
                        frameRate: { ideal: 60, min: 30 },
                        facingMode: { ideal: 'environment' },
                        focusMode: { ideal: 'continuous' },
                        exposureMode: { ideal: 'continuous' },
                        whiteBalanceMode: { ideal: 'continuous' },
                        aspectRatio: { ideal: 16/9 }
                    }
                };

                try {
                    // Stop existing stream
                    if (this.currentStream) {
                        this.currentStream.getTracks().forEach(track => track.stop());
                    }

                    this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const video = document.getElementById('camera-video');
                    video.srcObject = this.currentStream;

                    // Configure video element for optimal performance
                    video.setAttribute('playsinline', true);
                    video.setAttribute('webkit-playsinline', true);
                    video.muted = true;

                    // Get and analyze track capabilities
                    const track = this.currentStream.getVideoTracks()[0];
                    const settings = track.getSettings();
                    const capabilities = track.getCapabilities();

                    console.log('Camera settings:', settings);
                    console.log('Camera capabilities:', capabilities);

                    // Update capability flags
                    this.capabilities = {
                        torch: !!capabilities.torch,
                        zoom: !!capabilities.zoom,
                        focus: !!(capabilities.focusMode || capabilities.focusDistance)
                    };

                    // Show torch control if available
                    if (this.capabilities.torch) {
                        document.getElementById('torch-btn').style.display = 'flex';
                    }

                    // Apply professional camera settings
                    await this.applyProfessionalSettings(track, capabilities);

                    // Update quality indicator
                    this.updateQualityIndicator(settings, capabilities);

                    return new Promise((resolve) => {
                        video.addEventListener('loadedmetadata', () => {
                            console.log('Video dimensions:', video.videoWidth, 'x', video.videoHeight);
                            resolve();
                        });
                    });

                } catch (error) {
                    console.error('Professional camera setup failed:', error);
                    throw new Error('Failed to access camera with professional settings');
                }
            }

            async applyProfessionalSettings(track, capabilities) {
                const professionalConstraints = { advanced: [] };

                // Continuous autofocus for sharp barcode scanning
                if (capabilities.focusMode) {
                    professionalConstraints.advanced.push({ focusMode: 'continuous' });
                }

                // Optimal exposure for barcode contrast
                if (capabilities.exposureMode) {
                    professionalConstraints.advanced.push({ exposureMode: 'continuous' });
                }

                // Auto white balance for consistent colors
                if (capabilities.whiteBalanceMode) {
                    professionalConstraints.advanced.push({ whiteBalanceMode: 'continuous' });
                }

                // Apply constraints if any were set
                if (professionalConstraints.advanced.length > 0) {
                    try {
                        await track.applyConstraints(professionalConstraints);
                        console.log('Applied professional camera settings');
                    } catch (error) {
                        console.warn('Some professional settings could not be applied:', error);
                    }
                }
            }

            setupInteractionHandlers() {
                const video = document.getElementById('camera-video');

                // Touch-to-focus functionality
                video.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handleTouchFocus(e);
                }, { passive: false });

                // Click-to-focus for desktop
                video.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.handleClickFocus(e);
                });

                // Handle visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseScanning();
                    } else {
                        setTimeout(() => this.resumeScanning(), 1000);
                    }
                });

                // Prevent zoom on double tap
                video.addEventListener('touchend', (e) => {
                    e.preventDefault();
                });
            }

            async handleTouchFocus(e) {
                if (!this.capabilities.focus || !this.currentStream) return;

                const touch = e.touches[0];
                const video = document.getElementById('camera-video');
                const rect = video.getBoundingClientRect();

                const x = (touch.clientX - rect.left) / rect.width;
                const y = (touch.clientY - rect.top) / rect.height;

                await this.focusAt(x, y, touch.clientX, touch.clientY);
            }

            async handleClickFocus(e) {
                if (!this.capabilities.focus || !this.currentStream) return;

                const video = document.getElementById('camera-video');
                const rect = video.getBoundingClientRect();

                const x = (e.clientX - rect.left) / rect.width;
                const y = (e.clientY - rect.top) / rect.height;

                await this.focusAt(x, y, e.clientX, e.clientY);
            }

            async focusAt(x, y, screenX, screenY) {
                try {
                    const track = this.currentStream.getVideoTracks()[0];

                    // Apply single-shot focus with point of interest
                    await track.applyConstraints({
                        advanced: [{
                            focusMode: 'single-shot',
                            pointsOfInterest: [{ x: x, y: y }]
                        }]
                    });

                    // Show focus indicator
                    this.showFocusIndicator(screenX, screenY);

                    // Haptic feedback
                    this.vibrate([50]);

                    // Return to continuous focus after a moment
                    setTimeout(async () => {
                        try {
                            await track.applyConstraints({
                                advanced: [{ focusMode: 'continuous' }]
                            });
                        } catch (error) {
                            console.log('Could not return to continuous focus');
                        }
                    }, 2000);

                } catch (error) {
                    console.log('Manual focus not supported or failed:', error);
                }
            }

            showFocusIndicator(x, y) {
                const indicator = document.getElementById('focus-indicator');
                indicator.style.left = (x - 40) + 'px';
                indicator.style.top = (y - 40) + 'px';
                indicator.classList.add('active');

                setTimeout(() => {
                    indicator.classList.remove('active');
                }, 1000);
            }

            startContinuousScanning() {
                if (!this.codeReader || this.isScanning) return;

                this.isScanning = true;
                this.updateScanButton('scanning');
                this.updateReticle('scanning');
                this.updateStatus('Scanning for barcodes... Hold steady for best results', 'scanning');

                console.log('Starting ZXing continuous scanning...');

                // Start ZXing continuous decode with simplified error handling
                try {
                    this.codeReader.decodeFromVideoDevice(
                        undefined,
                        'camera-video',
                        (result, error) => {
                            if (result && result.text) {
                                console.log('Barcode found:', result.text);
                                const now = Date.now();
                                if (now - this.lastScanTime > this.scanCooldown) {
                                    this.lastScanTime = now;
                                    this.handleBarcodeDetected(result.text);
                                }
                            }

                            // Only log actual errors, not NotFoundException
                            if (error && error.name !== 'NotFoundException') {
                                console.log('Scan error:', error.name, error.message);
                            }
                        }
                    );
                } catch (error) {
                    console.error('Failed to start continuous scanning:', error);
                    this.updateStatus('Failed to start scanning: ' + error.message, 'error');
                }
            }

            async handleBarcodeDetected(code) {
                console.log('Barcode detected:', code);

                // Prevent duplicate processing
                if (this.lastDetectedCode === code) return;
                this.lastDetectedCode = code;

                // Enhanced feedback
                this.provideFeedback();

                // Update UI immediately
                this.updateReticle('found');
                this.updateScanButton('success');

                // Pause scanning during processing
                this.pauseScanning();

                try {
                    // Check if device exists and get its assignment status
                    const deviceStatus = await this.checkDeviceStatus(code);

                    if (deviceStatus.exists) {
                        if (deviceStatus.assigned) {
                            // Device is assigned - update pack status
                            await this.updatePackStatus(code);
                        } else {
                            // Device exists but not assigned
                            await this.assignDevice(code);
                        }
                    } else {
                        // Device doesn't exist
                        this.showResult({
                            type: 'error',
                            title: 'Device Not Found',
                            device: code,
                            status: 'Unknown Device',
                            action: 'Device not found in system'
                        });
                    }

                } catch (error) {
                    console.error('Error processing scanned device:', error);
                    this.showResult({
                        type: 'error',
                        title: 'Processing Failed',
                        device: code,
                        status: 'Error',
                        action: 'Failed to process: ' + error.message
                    });
                }
            }

            async checkDeviceStatus(deviceID) {
                try {
                    // Check if device exists
                    const deviceResponse = await fetch(`/api/v1/devices/${deviceID}`, {
                        headers: { 'Accept': 'application/json' }
                    });

                    if (!deviceResponse.ok) {
                        return { exists: false };
                    }

                    // Check if device is assigned to this job
                    const assignmentResponse = await fetch(`/api/v1/jobs/${this.jobID}/devices`, {
                        headers: { 'Accept': 'application/json' }
                    });

                    if (assignmentResponse.ok) {
                        const assignments = await assignmentResponse.json();
                        const isAssigned = assignments.devices &&
                                         assignments.devices.some(d => d.deviceID === deviceID);

                        return {
                            exists: true,
                            assigned: isAssigned
                        };
                    }

                    return { exists: true, assigned: false };

                } catch (error) {
                    console.error('Error checking device status:', error);
                    return { exists: false };
                }
            }

            async updatePackStatus(deviceID) {
                try {
                    const response = await fetch(`/api/v1/jobs/${this.jobID}/devices/${deviceID}/pack`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            pack_status: 'packed'
                        })
                    });

                    if (response.ok) {
                        this.showResult({
                            type: 'pack',
                            title: 'Device Packed!',
                            device: deviceID,
                            status: 'Assigned Device',
                            action: 'Marked as packed and ready'
                        });
                        this.vibrate([200, 100, 200]);
                    } else {
                        throw new Error('Failed to update pack status');
                    }

                } catch (error) {
                    console.error('Error updating pack status:', error);
                    this.showResult({
                        type: 'error',
                        title: 'Pack Update Failed',
                        device: deviceID,
                        status: 'Update Error',
                        action: 'Could not update pack status'
                    });
                }
            }

            async assignDevice(deviceID) {
                try {
                    const response = await fetch(`/api/v1/jobs/${this.jobID}/devices/${deviceID}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        this.showResult({
                            type: 'success',
                            title: 'Device Assigned!',
                            device: deviceID,
                            status: 'Available Device',
                            action: 'Successfully assigned to job'
                        });
                        this.vibrate([100, 50, 100]);
                    } else {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to assign device');
                    }

                } catch (error) {
                    console.error('Error assigning device:', error);
                    this.showResult({
                        type: 'error',
                        title: 'Assignment Failed',
                        device: deviceID,
                        status: 'Assignment Error',
                        action: error.message
                    });
                }
            }

            showResult(result) {
                // Update modal content
                document.getElementById('result-title').textContent = result.title;
                document.getElementById('result-device').textContent = result.device;
                document.getElementById('result-status').textContent = result.status;
                document.getElementById('result-action').textContent = result.action;

                // Update icon and colors based on result type
                const icon = document.getElementById('result-icon');
                const iconElement = icon.querySelector('i');

                icon.className = `result-icon ${result.type}`;

                switch (result.type) {
                    case 'success':
                        iconElement.className = 'bi bi-check-lg';
                        break;
                    case 'pack':
                        iconElement.className = 'bi bi-box-seam';
                        break;
                    case 'error':
                        iconElement.className = 'bi bi-exclamation-triangle';
                        break;
                }

                // Hide process button for errors
                const processBtn = document.getElementById('process-btn');
                if (result.type === 'error') {
                    processBtn.style.display = 'none';
                } else {
                    processBtn.style.display = 'inline-block';
                    document.getElementById('process-text').textContent =
                        result.type === 'pack' ? 'Packed' : 'Assigned';
                }

                // Show modal
                document.getElementById('modal-backdrop').classList.add('show');
                document.getElementById('result-modal').classList.add('show');

                // Auto-close after 4 seconds
                setTimeout(() => {
                    if (document.getElementById('result-modal').classList.contains('show')) {
                        this.continueScan();
                    }
                }, 4000);
            }

            provideFeedback() {
                // Haptic feedback
                this.vibrate([100, 50, 100]);

                // Audio feedback
                this.playSuccessSound();

                // Visual flash
                this.flashScreen();
            }

            vibrate(pattern) {
                if (navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            }

            playSuccessSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                    // Create a pleasant success tone
                    const frequencies = [800, 1000];
                    frequencies.forEach((freq, index) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.value = freq;
                        oscillator.type = 'sine';

                        const startTime = audioContext.currentTime + (index * 0.1);
                        const endTime = startTime + 0.15;

                        gainNode.gain.setValueAtTime(0.2, startTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, endTime);

                        oscillator.start(startTime);
                        oscillator.stop(endTime);
                    });

                } catch (error) {
                    console.log('Audio not supported');
                }
            }

            flashScreen() {
                const overlay = document.querySelector('.scanner-overlay');
                overlay.style.background = 'rgba(255,255,255,0.3)';
                setTimeout(() => {
                    overlay.style.background = '';
                }, 200);
            }

            async toggleTorch() {
                if (!this.capabilities.torch || !this.currentStream) return;

                try {
                    const track = this.currentStream.getVideoTracks()[0];
                    this.torchEnabled = !this.torchEnabled;

                    await track.applyConstraints({
                        advanced: [{ torch: this.torchEnabled }]
                    });

                    const torchBtn = document.getElementById('torch-btn');
                    torchBtn.classList.toggle('active', this.torchEnabled);

                    this.vibrate([50]);

                } catch (error) {
                    console.error('Torch control failed:', error);
                }
            }

            async switchCamera() {
                if (this.videoDevices.length <= 1) return;

                this.currentDeviceIndex = (this.currentDeviceIndex + 1) % this.videoDevices.length;

                this.pauseScanning();
                this.updateStatus('Switching camera...', 'info');

                try {
                    await this.setupProfessionalCamera();
                    setTimeout(() => {
                        this.startContinuousScanning();
                    }, 500);
                    this.vibrate([100]);
                } catch (error) {
                    console.error('Camera switch failed:', error);
                    this.updateStatus('Camera switch failed', 'error');
                }
            }

            pauseScanning() {
                if (this.codeReader && this.isScanning) {
                    this.codeReader.reset();
                    this.isScanning = false;
                    this.updateScanButton('default');
                    this.updateReticle('default');
                }
            }

            resumeScanning() {
                if (!this.isScanning && this.isInitialized) {
                    this.lastDetectedCode = null; // Reset last detected code
                    this.startContinuousScanning();
                }
            }

            updateScanButton(state) {
                const btn = document.getElementById('scan-btn');
                const icon = document.getElementById('scan-icon');

                btn.className = 'control-btn primary';

                switch (state) {
                    case 'scanning':
                        btn.classList.add('scanning');
                        icon.className = 'bi bi-pause';
                        break;
                    case 'success':
                        icon.className = 'bi bi-check-lg';
                        setTimeout(() => {
                            icon.className = 'bi bi-camera';
                        }, 2000);
                        break;
                    default:
                        icon.className = 'bi bi-camera';
                }
            }

            updateReticle(state) {
                const reticle = document.getElementById('scanner-reticle');
                reticle.className = 'scanner-reticle';

                if (state) {
                    reticle.classList.add(state);

                    if (state !== 'scanning') {
                        setTimeout(() => {
                            reticle.className = 'scanner-reticle scanning';
                        }, 2000);
                    }
                }
            }

            updateStatus(message, type = 'info') {
                const statusEl = document.getElementById('status-bar');
                const icons = {
                    success: 'check-circle-fill',
                    error: 'exclamation-triangle-fill',
                    info: 'info-circle-fill',
                    scanning: 'camera-video-fill'
                };

                statusEl.innerHTML = `<i class="bi bi-${icons[type] || 'info-circle-fill'}"></i> ${message}`;
            }

            updateQualityIndicator(settings, capabilities) {
                const indicator = document.getElementById('quality-indicator');
                const resolution = `${settings.width}x${settings.height}`;
                const frameRate = settings.frameRate ? Math.round(settings.frameRate) : 'N/A';
                const focusMode = settings.focusMode || (capabilities.focusMode ? 'Available' : 'Manual');

                indicator.innerHTML = `
                    Camera: ${resolution}@${frameRate}fps<br>
                    Focus: ${focusMode}<br>
                    Detection: Active
                `;
            }

            destroy() {
                if (this.currentStream) {
                    this.currentStream.getTracks().forEach(track => track.stop());
                }
                if (this.codeReader) {
                    this.codeReader.reset();
                }
                this.isInitialized = false;
            }
        }

        // Global scanner instance
        let professionalScanner;

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            professionalScanner = new ProfessionalBarcodeScanner();
        });

        // Global functions
        function toggleScanning() {
            if (professionalScanner.isScanning) {
                professionalScanner.pauseScanning();
            } else {
                professionalScanner.resumeScanning();
            }
        }

        function toggleTorch() {
            professionalScanner.toggleTorch();
        }

        function switchCamera() {
            professionalScanner.switchCamera();
        }

        function continueScan() {
            closeModal();
            setTimeout(() => professionalScanner.resumeScanning(), 500);
        }

        function closeModal() {
            document.getElementById('modal-backdrop').classList.remove('show');
            document.getElementById('result-modal').classList.remove('show');
        }

        function processResult() {
            // Result is already processed automatically
            continueScan();
        }

        function closeScanner() {
            professionalScanner.destroy();
            const jobID = {{.jobID}};
            if (jobID === "demo") {
                window.location.href = '/scan/select';
            } else {
                window.location.href = `/scan/${jobID}`;
            }
        }

        // Prevent default touch behaviors
        document.addEventListener('touchstart', (e) => {
            if (e.target.closest('.control-panel') || e.target.closest('.result-modal')) {
                return; // Allow normal touch on controls and modal
            }
            // For camera area, only prevent if it's near the edge (pull-to-refresh)
            const touch = e.touches[0];
            if (touch.clientY <= 100) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        // Handle visibility changes
        document.addEventListener('visibilitychange', () => {
            if (professionalScanner) {
                if (document.hidden) {
                    professionalScanner.pauseScanning();
                } else {
                    setTimeout(() => professionalScanner.resumeScanning(), 1000);
                }
            }
        });
    </script>
</body>
</html>